# hello_asm

and operator

一般课本不会讲的很细，因为没那么重要，但是这个东西可以开发看待的点有很多。

```
A AND B -> C
0     0    0
0     1    0
1     0    0
1     1    1
```

1. 二元操作符，区别于一元
2. 从结果来看，是为了筛选出全真的情况，即保证结果为真的需要1and2，因此命名为AND，即从C的角度看，有1则两个都满足，有0即起码有一个条件不满足，更何况两个都不满足了。那么着只是个初步判断，实际上你需要找补、解决问题的时候，你需要找到到底哪一环不行，所以C只是对结果的判断，真的想把事情做好，还得深入细致的去判断原先的每一个A或者B，甚至好几个AND串联只保证结果的判断而不得不深入每一环。除非联系后面的OR另寻出路，这条AB不是出不了结果1么，那就换OR的其他选项A1B1。
3. 但是基于四种真值表的具体搭配情况，可以通过很多其他方面去理解，比如，从0的角度看，就是含0则0.
4. 从操作数A来看，则对A进行AND 1操作，即用B的1来筛选A中的1和A中的1，比如子网掩码就是这么用。
5. 那么再来看AND 0操作有什么C的结果呢呢，只有00000，没有区别，即消除原来A所携带的信息

上面代表了初步的猜想、试探，其实总结下来就是对于A中的每一位，哪个位用1与就是保留这一位的原数，用0与就是混淆原数，因为原数可能是0可能是1，不一定错，所以不一定对。

但是00000看不出原先的信息，所以无所谓其中哪些对了，因为你不知道哪些位的0对了。看，这里部分的正确，但是你不知道哪个正确，所以也应当认为它是错误。

二元操作符在英文中可以用dyadic，虽然binary operation也可以，不过更精确一些，因为这个二元操作符不是指其数值系统用二进制，而是指其影响因子为2个。

只是恰巧，这里既是二元，元的值表示又是基于二进制的。

上面的真值表是一维的列表，其实可以简化为二维的列表
```
AND 0 1
0   0 0
1   0 1
```

这样更精简，只不过不大利于我人脑的思考方式，因为我还要脑部左边俩是A，上边俩是B，右下角四个值分别对应最后的结果C。很显然，只是比较看起来简介，但是用来归纳、演绎各种规律的尝试时不太方便：节省了纸的空间，却制造了更多理解的麻烦，就如同精简的高数课本，你还不如把辅导书写的好，一本是为了凸显自己的严谨正确，一本是为了学生怎么学着想，一口一喂。

就如同同样一个数值3000元，这里是十进制加中国元单位，其实还可以表示为二进制，也可以表示为美元作为单位，但不影响其本质表达的价值（value），而采用哪种形式在这里既重要，也不重要（在和价值相比较的时候）。

二进制上的逻辑运算符

OR

同为逻辑，其实不大懂什么叫逻辑，英文的logical翻译过来公平合理的，有原因的，应该的、有规律的，不是无缘无故的不是不公平的，符合事实的

那么言语上的逻辑和二进制上的逻辑运算，有什么不同呢

那就是二进制的运算的逻辑仅仅是二进制的运算，是人为规定的，不一定尽善尽美。只能做到尽量好用。这就是为什么AND的操作符的四种情况容易理解，但是蕴含的四种真值表不大容易懂，但那不重要，一致性才重要，随便弄一个即可。

OR

```
A B C
0 0 0
0 1 1
1 0 1
1 1 1
```

1. 从结果C来看，即为1则包含1，为0则一个都不行。这类似把A和B看作解决问题的并列选项而非相互搭配、依赖的一系列步骤。
2. 那么从实际操作来看，A或者B还是要选出到底哪个行啊，除非你两个解决方案同时进行，这样保证了结果就无所谓你们哪个方法是1（成功）的。
3. 从A的角度看，OR 0 可以保持原位的数不变，OR 1 则消除了信息，全为1了。
4. 所以OR 0 和 AND 1 一样，筛选出原先的A中的0 或者1.

这是几个角度呢，东西是依赖于解决问题而存在的，所以and 也好 or也好，要么是对A筛选，要么是对AB筛选出是否能成C。就这两个主要的角度，是解决问题的主要角度。

细分一下
1. 其中对A筛选，保持原位用OR 0和AND 1，如果想消除则AND 0，或者 OR 1.
2. 其中对AB判断，所有步骤用AND，选项option的判断用OR。option若能全部进行，在C为1的时候则不用细致管是哪个work，AND的步骤若全部进行，在C为1的时候全部都work了。
3. C要是为0，那么总结果已然保证不了，要么开源找新能work的方法为1， 使之OR结果为1，要么补全每个已有的旧方法的每一环，使之AND结果为1

从实现上来讲，and 遇见0 短路实现，or 遇见1短路实现.从机器的实现上，要考虑最小单位是8位的byte，从A的01分布来看，0多则多用and，1多则多用or，哪个更规律更适合做A就不要让它做B。

这些细节的知而不用，和不知而不用是不一样。很多时候写代码的coding时间、运行时间、debug时间、扩展新功能时间、换了员工之后的普适性要做一个平衡，需要哪个就往哪里侧重。所以平常不写极端优化的代码，但纵观全局在某些要害吃紧的地方要优化的时候你要会。不然你就是那个无关紧要只负责平常工作的那个，既然你不能临危受命，担不了责任，自然你也不会分利益的时候有你的更多

